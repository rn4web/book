
## 2.2 主要API、Component
### 2.2.1 StyleSheet API
StyleSheet API是整个系统样式处理系统的核心，在后面的章节会详细分析和介绍，此处因为组件编写需要，只对使用较多的样式做大致说明。
#### 2.2.1.1 主要的flexbox布局属性
我们在React Native以及React native for web中使用Flexbox布局系统来指定某个组件的子元素的布局。
Flexbox可以在不同屏幕尺寸上提供一致的布局结构。

常用的flex属性是：flexDirection、alignItems和 justifyContent。
flexDirection：控制flex布局方向，alignItems控制次轴方向等对齐方式，justifyContent控制主轴方向的对齐方式
1. FlexDirection

在组件的style中指定flexDirection决定flex布局的主轴。

控制子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列，

默认值是竖直轴(column)方向。

2. JustifyContent
   
在组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。
   
控制子元素靠近主轴的起始端还是末尾段分布,亦或是均匀分布
   
对应的这些可选项有：flex-start、center、flex-end、space-around以及space-between。

3. AlignItems

在组件的style中指定alignItems可以决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为column，则次轴方向为row）的排列方式。

控制子元素靠近次轴的起始端或是末尾段分布亦或是均匀分布。

对应的这些可选项有：flex-start、center、flex-end以及stretch。

4. 特别提示：

``` 
React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在一些差异。
首先是默认值不同：
flexDirection的默认值是column而不是row，
alignItems的默认值是stretch而不是flex-start，
以及flex只能指定一个数字值。
```

#### 2.2.1.2 React-Native for web的样式处理
在React Native以及React-Native for web中，并不需要学习新的语法来定义样式。仍然是使用JavaScript来写样式。
这些样式名基本上遵循了web的CSS的命名，按照JS的语法要求使用了驼峰命名法。
例如将background-color转变为backgroundColor。
特别提示：
```
当然对于低端机型，flex的支持并不是很好的情况下，在样式处理系统的章节中将详细介绍这种情况的处理。

```

style属性接收一个普通的javascript对象或者一个数组作为属性值，创建方式有三种：
1.直接在React component中传入样式对象，比如
<View style={{backgroundColor:'red'}}><View>

2.你还可以传入一个数组作为style的属性值,在数组中位置居后的样式对象比居前的优先级更高，这样你可以后面的样式对象覆盖前面的样式对象。
<View style={[styles.container,{backgroundColor:'red'}]}><View>

3.使用var styles=StyleSheet.create({
container:{backgroundColor:'red'}
})

实际开发中组件的样式会越来越复杂，推荐使用StyleSheet.create来集中定义组件的样式。

### 2.2.2View组件
View是创建UI时最基础的组件，是一个支持Flexbox布局、样式、触摸事件和一些其它功能的容器，
并且它可以嵌套到其它的视图里，也可以含有任意多个任意类型的子视图。
它是构建复合组件等更高级组件的基础组件。

#### 2.2.2.1View组件关键属性
1. style属性
View的样式定义和处理都靠style属性，由于View组件是所有布局组件的基础，View组件自身仅仅含有非常少量的处理逻辑，所以控制一个
View组件，主要是控制它的style属性和传入事件处理函数。
在View组件的内部实现中，会调用StyleSheet.fix处理样式，从而使得
style样式的解析和处理都进入样式处理系统StyleSheet中进行处理。


2. onLayout
当组件挂载或者布局变化的时候调用，参数为：{nativeEvent: { layout: {x, y, width, height}}}


3. pointerEvents属性
用于控制当前视图是否可以作为触控事件的目标，可以取如下的值：
    * `auto`：视图可以作为触控事件的目标。
    * `none`：视图不能作为触控事件的目标。
    * `box-none`：视图自身不能作为触控事件的目标，但其子视图可以。
    * `box-only`：视图自身可以作为触控事件的目标，但其子视图不能。

4. setNativeProps（nativeProps）

将nativeProps对象中的属性同步写回到真实dom元素，保持真实dom和虚拟dom的属性一致性。

5. measureLayout(relativeToNativeNode, onSuccess, onFail)
能够提供测量Component组件布局的方法，
其中onSuccess(x, y, width, height, left, top)回调函数中取得当前组件的width，height等布局信息。


### 2.2.3 Navigator组件


### 2.2.4 AppRegistry组件

### 2.2.5 ScrollView组件

ScrollView 滚动组件

ScrollView（滚动视图）的组件，集成了触摸事件的panResponder事件响应系统。

使用ScrollView必须有一个确定的高度才能正常工作，虽然也能实现自适应布局，但是在低端机上经常出现意料之外的样式问题。
ScrollView实际上是将一系列不确定高度的子组件装进一个确定高度的容器。所以要么容器的高度确定，要么ScrollView上设置合适的高度。


#### 2.2.5.1 ScrollView组件关键属性
1. 

2.